<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° Gemini Dev Assistant - GitHub UI</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-primary: #0d1117; 
            --bg-secondary: #161b22; 
            --border-color: #30363d;
            --text-color: #c9d1d9;
            --link-color: #58a6ff;
            --ai-bubble-bg: #21262d; 
            --user-bubble-bg: #2d3840;
            --button-bg: #238636; 
            --button-hover: #2ea043;
            --code-bg: rgba(110, 118, 129, 0.4);
            --radius: 6px;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-color);
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        hgroup h1, hgroup p, h3 { color: var(--text-color); }

        #chat-container {
            height: 70vh;
            overflow-y: scroll;
            padding: 15px;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
            margin-bottom: 20px;
        }

        .message-box {
            padding: 12px;
            margin-bottom: 15px;
            border-radius: var(--radius);
            max-width: 85%;
            word-wrap: break-word;
            line-height: 1.5;
        }

        .user-message {
            background-color: var(--user-bubble-bg);
            margin-left: auto; 
            border: 1px solid var(--border-color);
        }

        .ai-message {
            background-color: var(--ai-bubble-bg);
            margin-right: auto;
            border: 1px solid var(--border-color);
        }

        .system-message {
            background-color: rgba(88, 166, 255, 0.1);
            border: 1px solid var(--link-color);
            margin: 10px auto;
            text-align: center;
            font-style: italic;
            color: var(--link-color);
        }

        #input-area {
            display: flex;
            gap: 10px;
        }

        #chat-input {
            flex-grow: 1;
            padding: 10px 15px;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            background-color: var(--bg-secondary);
            color: var(--text-color);
            font-size: 16px;
        }

        button {
            padding: 10px 20px;
            border-radius: var(--radius);
            border: none;
            background-color: var(--button-bg);
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
            font-weight: 700;
        }

        button:hover {
            background-color: var(--button-hover);
        }

        .github-tools {
            margin-top: 30px;
            padding: 20px;
            background-color: var(--bg-secondary);
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .select-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #repo-select {
            padding: 8px 15px;
            border-radius: var(--radius);
            border: 1px solid var(--border-color);
            background-color: var(--bg-primary);
            color: var(--text-color);
            font-size: 16px;
        }

        code {
            font-family: 'IBM Plex Mono', monospace;
            background-color: var(--code-bg);
            padding: 2px 4px;
            border-radius: 4px;
            color: var(--text-color);
        }

        pre {
            background-color: var(--code-bg);
            padding: 10px;
            border-radius: var(--radius);
            overflow-x: auto;
            font-family: 'IBM Plex Mono', monospace;
        }

        .view-btn {
            background-color: #30363d;
            padding: 8px 15px;
            margin-top: 10px;
        }

        .view-btn:hover {
            background-color: #454d56;
        }

    </style>
</head>
<body>
    <hgroup>
        <h1>ü§ñ Gemini Dev Assistant</h1>
        <p>Chat com IA para gerenciar e corrigir c√≥digo no GitHub. A IA decide automaticamente quando usar ferramentas.</p>
    </hgroup>
    <hr style="border-color: var(--border-color);">

    <div id="chat-container">
    </div>

    <form id="chat-form">
        <div id="input-area">
            <input type="text" id="chat-input" name="prompt" placeholder="Ex: 'mostre o conte√∫do do README', 'crie um arquivo teste.js', 'corrija o erro no index.js'">
            <button type="submit">Enviar</button>
        </div>
    </form>

    <div class="github-tools">
        <h3>üîß Configura√ß√µes GitHub</h3>
        
        <div class="select-container">
            <label for="repo-select">Reposit√≥rio Selecionado:</label>
            <select id="repo-select">
                <option value="">Carregando reposit√≥rios...</option>
            </select>
        </div>

        <button class="view-btn" onclick="viewRepoStructure()">üîç Ver Estrutura do Reposit√≥rio</button>

        <div style="margin-top: 10px; padding: 10px; background-color: var(--bg-primary); border-radius: var(--radius);">
            <p style="margin: 5px 0; font-size: 14px;"><strong>üí° Dicas de uso:</strong></p>
            <p style="margin: 5px 0; font-size: 13px;">‚Ä¢ "Mostre o conte√∫do do arquivo X"</p>
            <p style="margin: 5px 0; font-size: 13px;">‚Ä¢ "Crie um arquivo novo chamado Y com o c√≥digo Z"</p>
            <p style="margin: 5px 0; font-size: 13px;">‚Ä¢ "Edite o arquivo X e adicione Y"</p>
            <p style="margin: 5px 0; font-size: 13px;">‚Ä¢ "Delete o arquivo X"</p>
            <p style="margin: 5px 0; font-size: 13px;">‚Ä¢ "Corrija o erro no arquivo X"</p>
        </div>
    </div>

    <script>
        const chatContainer = document.getElementById('chat-container');
        const chatForm = document.getElementById('chat-form');
        const repoSelect = document.getElementById('repo-select');
        const STORAGE_KEY = 'geminiChatHistory';
        
        const API_KEY = 'AIzaSyB7ou_FpcqAcb21dv5BKoXZl_ve2NHhA3I'; 
        const GITHUB_PAT = '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'; 
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent';
        const GITHUB_API_URL = 'https://api.github.com';
        
        const SYSTEM_INSTRUCTION = `Voc√™ √© o 'Gemini Code Assistant', um assistente especializado em GitHub que pode executar a√ß√µes automaticamente.

Quando o usu√°rio pedir para:
- LER/VER/MOSTRAR um arquivo ‚Üí responda APENAS: /Read { caminho/arquivo }
- CRIAR/ADICIONAR um arquivo ‚Üí responda APENAS: /Create { caminho/arquivo, conte√∫do completo }
- EDITAR/MODIFICAR/ATUALIZAR um arquivo ‚Üí responda APENAS: /Edit { caminho/arquivo, conte√∫do completo novo }
- DELETAR/REMOVER um arquivo ‚Üí responda APENAS: /Delete { caminho/arquivo }

IMPORTANTE:
1. Use APENAS o comando sem texto adicional quando for executar uma a√ß√£o
2. No /Edit e /Create, sempre coloque o conte√∫do COMPLETO do arquivo
3. Se n√£o souber o conte√∫do atual, primeiro use /Read para ler
4. Para corre√ß√µes de erro: primeiro leia o arquivo, analise, depois edite
5. Para perguntas gerais sobre c√≥digo, responda normalmente SEM comandos

Exemplos:
Usu√°rio: "mostre o README"
Voc√™: /Read { README.md }

Usu√°rio: "crie um index.html b√°sico"
Voc√™: /Create { index.html, <!DOCTYPE html><html><head><title>Test</title></head><body><h1>Hello</h1></body></html> }

Usu√°rio: "o que √© uma API REST?"
Voc√™: [explica√ß√£o normal sem comando]`;

        function getSelectedRepo() {
            const full_name = repoSelect.value;
            if (!full_name) {
                appendMessage('system', '‚ö†Ô∏è Selecione um reposit√≥rio antes de continuar');
                return null;
            }
            const [owner, name] = full_name.split('/');
            return { owner, name, full_name };
        }

        async function githubApiFetch(url, options = {}) {
            const headers = {
                'Authorization': `token ${GITHUB_PAT}`,
                'Accept': 'application/vnd.github.v3+json',
                ...options.headers
            };

            const response = await fetch(url, { ...options, headers });
            
            if (!response.ok) {
                let errorDetails = await response.text();
                throw new Error(`Erro ${response.status}: ${errorDetails}`);
            }
            
            return response.json();
        }

        async function fetchRepositories() {
            repoSelect.innerHTML = '<option value="">Carregando...</option>';
            try {
                const repos = await githubApiFetch(`${GITHUB_API_URL}/user/repos?type=owner&sort=updated&per_page=100`);
                repoSelect.innerHTML = '<option value="">-- Selecione um Reposit√≥rio --</option>';
                repos.forEach(repo => {
                    const option = document.createElement('option');
                    option.value = repo.full_name;
                    option.textContent = repo.full_name;
                    repoSelect.appendChild(option);
                });
            } catch (error) {
                repoSelect.innerHTML = '<option value="">Erro ao carregar</option>';
                appendMessage('system', `‚ùå Erro ao carregar reposit√≥rios: ${error.message}`);
            }
        }

        async function readFile(repo, path) {
            const url = `${GITHUB_API_URL}/repos/${repo.owner}/${repo.name}/contents/${path}`;
            const fileData = await githubApiFetch(url);
            
            if (fileData.content) {
                return {
                    content: decodeURIComponent(escape(atob(fileData.content))),
                    sha: fileData.sha
                };
            }
            throw new Error(`Arquivo vazio ou inv√°lido`);
        }

        async function deleteFile(repo, path, sha) {
            const url = `${GITHUB_API_URL}/repos/${repo.owner}/${repo.name}/contents/${path}`;
            await githubApiFetch(url, {
                method: 'DELETE',
                body: JSON.stringify({
                    message: `Delete ${path} via Gemini Assistant`,
                    sha: sha,
                    branch: 'main'
                })
            });
        }

        async function createOrEditFile(repo, path, content, sha = null) {
            const url = `${GITHUB_API_URL}/repos/${repo.owner}/${repo.name}/contents/${path}`;
            const encodedContent = btoa(unescape(encodeURIComponent(content)));
            const action = sha ? 'Update' : 'Create';
            
            const body = {
                message: `${action} ${path} via Gemini Assistant`,
                content: encodedContent,
                branch: 'main'
            };
            if (sha) body.sha = sha;

            await githubApiFetch(url, {
                method: 'PUT',
                body: JSON.stringify(body)
            });
        }

        async function fetchRepoTree(repo) {
            const url = `${GITHUB_API_URL}/repos/${repo.owner}/${repo.name}/git/trees/main?recursive=1`;
            const data = await githubApiFetch(url);
            return data.tree || [];
        }

        async function viewRepoStructure() {
            const repo = getSelectedRepo();
            if (!repo) return;
            
            appendMessage('system', 'üìÇ Carregando estrutura do reposit√≥rio...');
            
            try {
                const tree = await fetchRepoTree(repo);
                const files = tree.filter(item => item.type === 'blob').map(item => item.path);
                const folders = tree.filter(item => item.type === 'tree').map(item => item.path);
                
                let structure = `üìÇ Estrutura de ${repo.full_name}:\n\n`;
                structure += `üìÅ Pastas (${folders.length}):\n${folders.map(f => '  ‚îî‚îÄ ' + f).join('\n')}\n\n`;
                structure += `üìÑ Arquivos (${files.length}):\n${files.map(f => '  ‚îî‚îÄ ' + f).join('\n')}`;
                
                appendMessage('ai', structure);
            } catch (error) {
                appendMessage('system', `‚ùå Erro: ${error.message}`);
            }
        }

        async function processCommand(command) {
            const repo = getSelectedRepo();
            if (!repo) return null;

            const readMatch = command.match(/^\/Read\s+\{\s*(.+?)\s*\}$/i);
            const deleteMatch = command.match(/^\/Delete\s+\{\s*(.+?)\s*\}$/i);
            const createMatch = command.match(/^\/Create\s+\{\s*(.+?)\s*,\s*(.+)\s*\}$/is);
            const editMatch = command.match(/^\/Edit\s+\{\s*(.+?)\s*,\s*(.+)\s*\}$/is);

            try {
                if (readMatch) {
                    const path = readMatch[1].trim();
                    appendMessage('system', `üìñ Lendo arquivo: ${path}`);
                    const file = await readFile(repo, path);
                    return `Conte√∫do de ${path}:\n\n\`\`\`\n${file.content}\n\`\`\``;
                }

                if (deleteMatch) {
                    const path = deleteMatch[1].trim();
                    appendMessage('system', `üóëÔ∏è Deletando arquivo: ${path}`);
                    const file = await readFile(repo, path);
                    await deleteFile(repo, path, file.sha);
                    return `‚úÖ Arquivo ${path} deletado com sucesso!`;
                }

                if (createMatch) {
                    const path = createMatch[1].trim();
                    const content = createMatch[2].trim();
                    appendMessage('system', `‚ûï Criando arquivo: ${path}`);
                    await createOrEditFile(repo, path, content);
                    return `‚úÖ Arquivo ${path} criado com sucesso!`;
                }

                if (editMatch) {
                    const path = editMatch[1].trim();
                    const content = editMatch[2].trim();
                    appendMessage('system', `‚úèÔ∏è Editando arquivo: ${path}`);
                    
                    let sha = null;
                    try {
                        const file = await readFile(repo, path);
                        sha = file.sha;
                    } catch (e) {
                        appendMessage('system', `‚ö†Ô∏è Arquivo n√£o encontrado, criando novo...`);
                    }
                    
                    await createOrEditFile(repo, path, content, sha);
                    return `‚úÖ Arquivo ${path} atualizado com sucesso!`;
                }
            } catch (error) {
                return `‚ùå Erro ao executar comando: ${error.message}`;
            }
            
            return null;
        }

        async function sendToGemini(prompt) {
            const history = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]')
                .filter(msg => msg.sender !== 'system');
            
            const contents = history.map(msg => ({
                role: msg.sender === 'user' ? 'user' : 'model',
                parts: [{ text: msg.text }]
            }));

            const response = await fetch(`${GEMINI_API_URL}?key=${API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [...contents, { role: 'user', parts: [{ text: prompt }] }],
                    systemInstruction: { parts: [{ text: SYSTEM_INSTRUCTION }] }
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error?.message || 'Erro na API');
            }

            const data = await response.json();
            return data.candidates[0]?.content?.parts[0]?.text || 'Sem resposta da IA';
        }

        chatForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const input = document.getElementById('chat-input');
            const prompt = input.value.trim();
            
            if (!prompt) return;
            if (!getSelectedRepo()) return;

            appendMessage('user', prompt);
            input.value = '';

            try {
                const aiResponse = await sendToGemini(prompt);
                
                // Verifica se a IA retornou um comando
                if (aiResponse.trim().startsWith('/')) {
                    const commandResult = await processCommand(aiResponse.trim());
                    if (commandResult) {
                        appendMessage('ai', commandResult);
                    } else {
                        appendMessage('ai', aiResponse);
                    }
                } else {
                    appendMessage('ai', aiResponse);
                }
            } catch (error) {
                appendMessage('system', `‚ùå Erro: ${error.message}`);
            }
        });

        function saveChatHistory() {
            const historyElements = chatContainer.querySelectorAll('.message-box');
            const historyToSave = [];

            historyElements.forEach(el => {
                let sender = 'ai';
                if (el.classList.contains('user-message')) sender = 'user';
                if (el.classList.contains('system-message')) sender = 'system';
                
                historyToSave.push({
                    sender: sender,
                    text: el.textContent.trim()
                });
            });

            localStorage.setItem(STORAGE_KEY, JSON.stringify(historyToSave));
        }

        function appendMessage(sender, text, shouldSave = true) {
            const messageEl = document.createElement('div');
            messageEl.classList.add('message-box');
            
            if (sender === 'user') {
                messageEl.classList.add('user-message');
            } else if (sender === 'system') {
                messageEl.classList.add('system-message');
            } else {
                messageEl.classList.add('ai-message');
            }
            
            messageEl.textContent = text;
            chatContainer.appendChild(messageEl);
            chatContainer.scrollTop = chatContainer.scrollHeight;

            if (shouldSave) saveChatHistory();
        }

        function loadChatHistory() {
            const history = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
            
            if (history.length === 0) {
                history.push({ 
                    sender: 'ai', 
                    text: 'üëã Ol√°! Sou o Gemini Assistant. Selecione um reposit√≥rio e me pe√ßa para ler, criar, editar ou deletar arquivos. Eu decido automaticamente qual ferramenta usar!' 
                });
            }

            chatContainer.innerHTML = '';
            history.forEach(msg => appendMessage(msg.sender, msg.text, false));
        }

        fetchRepositories();
        loadChatHistory();
    </script>
</body>
</html>
